<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cocos2d-x使用AssetsManager遇见下载错误问题</title>
    <url>/2020/03/31/Cocos2d-x%E4%BD%BF%E7%94%A8AssetsManager%E9%81%87%E8%A7%81%E4%B8%8B%E8%BD%BD%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>前段时间在测试其他功能的时候,发现了关于AssetsManager奇怪的问题,</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/20200331141647.png"></p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/20200331141642.png"></p>
<p>由于现网项目有内容需要更新,使用的是Cocos2d-x引擎,更新是通过AssetsManager来进行的.于是我将测试环境上的.manifess文件从0.0.4版本更新到0.0.5版本,上图可以看到md5也同样发生了改变.然而在随后的测试过程中遇到了下载错误的问题.</p>
<p>测试过程中有一台设备的manifest文件顺利从0.0.4更新到了0.0.5,</p>
<p>但是应用运行发现它并没有出现预期中的最新功能,将设备里的DOWN_LOAD_CONTENT_1.0.1.zip扒拉下来才发现这个包有问题.它里面并没有包含新功能的代码以及资源</p>
<p>经过md5对比,发现下载下来的zip包其实是0.0.4版本的.</p>
<p>这就很奇怪了</p>
<p>并且这个现象只在这台设备上出现了一次,重新测试之后下载的zip包就是0.0.5版本的了.</p>
<p>由于最近使用七牛云,经常发现有些节点异常,所以刚发现问题的时候就觉得是七牛云那边CDN缓存的问题,某个节点上的manifest文件已经刷新成0.0.5版本了,但是相对应的zip包还没有及时刷新,这时有个设备从这个节点下载数据可能会有以上问题,但是为什么会将md5不对的zip包下载到设备里呢?</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>我随便测试了下,发现只要manifest文件中的version和资源的md5发生改变,就会触发AssetsManager去下载节点上的zip包,而不管服务器上的zip包是否正确.</p>
<p>看了下AssetsManager的源码,了解它的大致流程</p>
<h3 id="1-下载远程的manifest文件"><a href="#1-下载远程的manifest文件" class="headerlink" title="1.下载远程的manifest文件"></a>1.下载远程的manifest文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssetsManagerEx::downloadManifest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        _updateState = State::DOWNLOADING_MANIFEST;</span><br><span class="line">        <span class="comment">// Download version file asynchronously</span></span><br><span class="line">        _downloader-&gt;<span class="built_in">createDownloadFileTask</span>(manifestUrl, _tempManifestPath, MANIFEST_ID);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-对比本地和远程的manifest文件version"><a href="#2-对比本地和远程的manifest文件version" class="headerlink" title="2.对比本地和远程的manifest文件version"></a>2.对比本地和远程的manifest文件version</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssetsManagerEx::parseManifest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (_localManifest-&gt;<span class="built_in">versionGreater</span>(_remoteManifest, _versionCompareHandle))<span class="comment">//对比本地和远程的manifest文件的version是否一致</span></span><br><span class="line">        &#123;</span><br><span class="line">            _updateState = State::UP_TO_DATE;</span><br><span class="line">            _fileUtils-&gt;<span class="built_in">removeDirectory</span>(_tempStoragePath);</span><br><span class="line">            <span class="built_in">dispatchUpdateEvent</span>(EventAssetsManagerEx::EventCode::ALREADY_UP_TO_DATE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _updateState = State::NEED_UPDATE;</span><br><span class="line">            <span class="built_in">dispatchUpdateEvent</span>(EventAssetsManagerEx::EventCode::NEW_VERSION_FOUND);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_updateEntry == UpdateEntry::DO_UPDATE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">startUpdate</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-若是version不一致-则开始下载远程的对应文件"><a href="#3-若是version不一致-则开始下载远程的对应文件" class="headerlink" title="3.若是version不一致,则开始下载远程的对应文件"></a>3.若是version不一致,则开始下载远程的对应文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssetsManagerEx::startUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        std::unordered_map&lt;std::string, Manifest::AssetDiff&gt; diff_map = _localManifest-&gt;<span class="built_in">genDiff</span>(_remoteManifest);<span class="comment">//获取本地和远程manifest文件assets上的差异</span></span><br><span class="line">        <span class="keyword">if</span> (diff_map.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">updateSucceed</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="comment">//若有差异,则打包一起下载</span></span><br><span class="line">            <span class="comment">// Generate download units for all assets that need to be updated or added</span></span><br><span class="line">            std::string packageUrl = _remoteManifest-&gt;<span class="built_in">getPackageUrl</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Preprocessing local files in previous version and creating download folders</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = diff_map.<span class="built_in">begin</span>(); it != diff_map.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                Manifest::AssetDiff diff = it-&gt;second;</span><br><span class="line">                <span class="keyword">if</span> (diff.type != Manifest::DiffType::DELETED)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::string path = diff.asset.path;</span><br><span class="line">                    DownloadUnit unit;</span><br><span class="line">                    unit.customId = it-&gt;first;</span><br><span class="line">                    unit.srcUrl = packageUrl + path;</span><br><span class="line">                    unit.storagePath = _tempStoragePath + path;</span><br><span class="line">                    unit.size = diff.asset.size;</span><br><span class="line">                    _downloadUnits.<span class="built_in">emplace</span>(unit.customId, unit);</span><br><span class="line">                    _tempManifest-&gt;<span class="built_in">setAssetDownloadState</span>(it-&gt;first, Manifest::DownloadState::UNSTARTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">// Save current download manifest information for resuming</span></span><br><span class="line">			_tempManifest-&gt;<span class="built_in">saveToFile</span>(_tempManifestPath);</span><br><span class="line"></span><br><span class="line">            _totalWaitToDownload = _totalToDownload = (<span class="type">int</span>)_downloadUnits.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">batchDownload</span>();</span><br><span class="line"></span><br><span class="line">            std::string msg = StringUtils::format(<span class="string">&quot;Start to update %d files from remote package.&quot;</span>, _totalToDownload);</span><br><span class="line">            <span class="built_in">dispatchUpdateEvent</span>(EventAssetsManagerEx::EventCode::UPDATE_PROGRESSION, <span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//对比manifest文件asserts差异的代码,若本地manifest里的文件md5和远程manifest里的文件md5不一致,则判断该文件需要下载</span></span><br><span class="line"><span class="function">std::unordered_map&lt;std::string, Manifest::AssetDiff&gt; <span class="title">Manifest::genDiff</span><span class="params">(<span class="type">const</span> Manifest *b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unordered_map&lt;std::string, AssetDiff&gt; diff_map;</span><br><span class="line">    <span class="type">const</span> std::unordered_map&lt;std::string, Asset&gt; &amp;bAssets = b-&gt;<span class="built_in">getAssets</span>();</span><br><span class="line"></span><br><span class="line">    std::string key;</span><br><span class="line">    Asset valueA;</span><br><span class="line">    Asset valueB;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;std::string, Asset&gt;::const_iterator valueIt, it;</span><br><span class="line">    <span class="keyword">for</span> (it = _assets.<span class="built_in">begin</span>(); it != _assets.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        key = it-&gt;first;</span><br><span class="line">        valueA = it-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deleted</span></span><br><span class="line">        valueIt = bAssets.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (valueIt == bAssets.<span class="built_in">cend</span>()) &#123;</span><br><span class="line">            AssetDiff diff;</span><br><span class="line">            diff.asset = valueA;</span><br><span class="line">            diff.type = DiffType::DELETED;</span><br><span class="line">            diff_map.<span class="built_in">emplace</span>(key, diff);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Modified</span></span><br><span class="line">        valueB = valueIt-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (valueA.md5 != valueB.md5) &#123;</span><br><span class="line">            AssetDiff diff;</span><br><span class="line">            diff.asset = valueB;</span><br><span class="line">            diff.type = DiffType::MODIFIED;</span><br><span class="line">            diff_map.<span class="built_in">emplace</span>(key, diff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (it = bAssets.<span class="built_in">begin</span>(); it != bAssets.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        key = it-&gt;first;</span><br><span class="line">        valueB = it-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Added</span></span><br><span class="line">        valueIt = _assets.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (valueIt == _assets.<span class="built_in">cend</span>()) &#123;</span><br><span class="line">            AssetDiff diff;</span><br><span class="line">            diff.asset = valueB;</span><br><span class="line">            diff.type = DiffType::ADDED;</span><br><span class="line">            diff_map.<span class="built_in">emplace</span>(key, diff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diff_map;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="4-问题就出现在以下代码-下载成功之后的处理"><a href="#4-问题就出现在以下代码-下载成功之后的处理" class="headerlink" title="4.问题就出现在以下代码,下载成功之后的处理"></a>4.问题就出现在以下代码,下载成功之后的处理</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssetsManagerEx::onSuccess</span><span class="params">(<span class="type">const</span> std::string &amp;<span class="comment">/*srcUrl*/</span>, <span class="type">const</span> std::string &amp;storagePath, <span class="type">const</span> std::string &amp;customId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (customId == VERSION_ID)</span><br><span class="line">    &#123;</span><br><span class="line">        _updateState = State::VERSION_LOADED;</span><br><span class="line">        <span class="built_in">parseVersion</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (customId == MANIFEST_ID)</span><br><span class="line">    &#123;</span><br><span class="line">        _updateState = State::MANIFEST_LOADED;</span><br><span class="line">        <span class="built_in">parseManifest</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> &amp;assets = _remoteManifest-&gt;<span class="built_in">getAssets</span>();</span><br><span class="line">        <span class="keyword">auto</span> assetIt = assets.<span class="built_in">find</span>(customId);</span><br><span class="line">        <span class="keyword">if</span> (assetIt != assets.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Manifest::Asset asset = assetIt-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (_verifyCallback != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ok = _verifyCallback(storagePath, asset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ok)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> compressed = assetIt != assets.<span class="built_in">end</span>() ? assetIt-&gt;second.compressed : <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compressed)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">decompressDownloadedZip</span>(customId, storagePath);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fileSuccess</span>(customId, storagePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fileError</span>(customId, <span class="string">&quot;Asset file verification failed after downloaded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>可以看见,下载成功以后并没有对下载文件做任何校验.直接判断这次更新成功,并将本地的manifest更新为和远程一样.<br>于是我稍微改了一下,对下载下来的文件做下md5校验</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AssetsManagerEx::onSuccess</span><span class="params">(<span class="type">const</span> std::string &amp;<span class="comment">/*srcUrl*/</span>, <span class="type">const</span> std::string &amp;storagePath, <span class="type">const</span> std::string &amp;customId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (customId == VERSION_ID)</span><br><span class="line">    &#123;</span><br><span class="line">        _updateState = State::VERSION_LOADED;</span><br><span class="line">        <span class="built_in">parseVersion</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (customId == MANIFEST_ID)</span><br><span class="line">    &#123;</span><br><span class="line">        _updateState = State::MANIFEST_LOADED;</span><br><span class="line">        <span class="built_in">parseManifest</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> &amp;assets = _remoteManifest-&gt;<span class="built_in">getAssets</span>();</span><br><span class="line">        <span class="keyword">auto</span> assetIt = assets.<span class="built_in">find</span>(customId);</span><br><span class="line">        <span class="keyword">if</span> (assetIt != assets.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Manifest::Asset asset = assetIt-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (_verifyCallback != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ok = _verifyCallback(storagePath, asset);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下载成功后做下md5校验</span></span><br><span class="line">            FileUtils::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getContents</span>(storagePath, &amp;data);</span><br><span class="line">			<span class="keyword">if</span> (ok &amp;&amp; asset.md5 != <span class="string">&quot;&quot;</span> &amp;&amp; !data.<span class="built_in">isNull</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">md5_state_t</span> state;</span><br><span class="line">				<span class="type">md5_byte_t</span> digest[<span class="number">16</span>];</span><br><span class="line">				<span class="type">char</span> downloadmd5[(<span class="number">16</span> &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">				<span class="built_in">md5_init</span>(&amp;state);</span><br><span class="line">				<span class="built_in">md5_append</span>(&amp;state, (<span class="type">const</span> <span class="type">md5_byte_t</span> *)data.<span class="built_in">getBytes</span>(), (<span class="type">int</span>)data.<span class="built_in">getSize</span>());</span><br><span class="line">				<span class="built_in">md5_finish</span>(&amp;state, digest);</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> di = <span class="number">0</span>; di &lt; <span class="number">16</span>; ++di)</span><br><span class="line">					<span class="built_in">sprintf</span>(downloadmd5 + di * <span class="number">2</span>, <span class="string">&quot;%02x&quot;</span>, digest[di]);</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">strcmp</span>(downloadmd5, asset.md5.<span class="built_in">c_str</span>()) != <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ok = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ok)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> compressed = assetIt != assets.<span class="built_in">end</span>() ? assetIt-&gt;second.compressed : <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compressed)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">decompressDownloadedZip</span>(customId, storagePath);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fileSuccess</span>(customId, storagePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fileError</span>(customId, <span class="string">&quot;Asset file verification failed after downloaded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以解决CDN缓存导致下载错误的问题,</p>
<p>当然,这里仍然存在一个问题,若更新包里有上千个文件,那就要进行上千次md5校验.这个过程将会十分耗时,影响体验.测试了下上千个文件进行md5校验,大约耗时3~4秒</p>
<p>但由于我们项目的一个更新包里往往只对应一个zip包,md5校验的耗时几乎可以忽略不计,具体使用中也没什么感知.</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Cocos2d-x</tag>
        <tag>AssetsManager</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3异步编程尝试</title>
    <url>/2020/04/11/Python3%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<p>之前为了方便进行项目的热更新，使用python写了套自动对比打包工具，实际使用发现完成一次完整的流程至少需要五分钟，苦于没有时间改进代码，只能继续忍受了一段时间。</p>
<p>上周终于闲了下来，于是麻溜地开始调试打包工具</p>
<hr>
<h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><ol>
<li>对比本地资源以及服务器资源</li>
</ol>
<blockquote>
<p>为了方便本地开发以及测试，该项目所有需要下载的资源都放在一个特定的assetsRes目录之中。</p>
</blockquote>
<blockquote>
<p>在开发以及测试初期，相关人员都可以在local版本上进行调试、开发、测试。</p>
</blockquote>
<blockquote>
<p>开发，测试完成后会将assetsRes目录里的资源打包上传到七牛云上。然而由于七牛云的目录结构并不是所有资源放在一个包，而是区分功能放在不同的路径之下。</p>
</blockquote>
<blockquote>
<p>所以工具的第一步是将本地的目录结构转化为七牛云上的目录结构</p>
</blockquote>
<ol start="2">
<li>对比文件新增、修改、删除</li>
</ol>
<blockquote>
<p>这一步没啥好说的，就是遍历目录，根据md5以及文件树来找出发生变动的文件。</p>
</blockquote>
<blockquote>
<p>打印出所有的修改，并且询问是否需要将修改上传至七牛云</p>
</blockquote>
<ol start="3">
<li>上传至七牛云</li>
</ol>
<blockquote>
<p>这里研究一下<a href="https://developer.qiniu.com/kodo/sdk/1242/python">七牛云的SDK文档</a>就好了，文档里都写得很详细。</p>
</blockquote>
<blockquote>
<p>一开始的时候我把所有上传文件的CDN都刷新了一遍，后来发现七牛云刷新CDN是有次数限制的，后来就更改为只刷新修改文件的CDN</p>
</blockquote>
<h3 id="调试、优化"><a href="#调试、优化" class="headerlink" title="调试、优化"></a>调试、优化</h3><p>经过调试发现，最耗时的是整个流程的第一步：对比本地资源以及服务器资源，足足用了100多秒才生成完毕。</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/20200411162657.png"></p>
<p>在这一步，要对将近100多个资源包进行复制、加密、计算md5、生成manifest。以后增加新功能，资源包的数量只会越来越多，耗时也会越来越恐怖。</p>
<p>本来是打算使用threading试下的，结果在查资料的时候发现了async\await，这篇文章就是记录一下学习</p>
<h3 id="Python异步并发"><a href="#Python异步并发" class="headerlink" title="Python异步并发"></a>Python异步并发</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br></pre></td></tr></table></figure>

<h4 id="同步函数"><a href="#同步函数" class="headerlink" title="同步函数"></a>同步函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">i</span>):</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">url = [<span class="string">&quot;https://www.qq.com/&quot;</span>,</span><br><span class="line">       <span class="string">&quot;https://www.youku.com/&quot;</span>,</span><br><span class="line">       <span class="string">&quot;https://www.baidu.com/&quot;</span>]</span><br><span class="line"></span><br><span class="line">test1(i)) <span class="keyword">for</span> i <span class="keyword">in</span> url</span><br></pre></td></tr></table></figure>

<p>在同步函数中，会等待函数中所有代码执行完毕之后才会返回。以上代码通过for循环将所有的url打印出来，每次打印过程会等待4秒，整个函数执行完毕需要12秒。</p>
<h4 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h4><p>同样是打印所有的url，同样每次打印的等待时间是4s，异步函数执行完毕只需要4秒就可以了。相比于同步函数，耗时足足减少了30%</p>
<p>在python中简单使用异步函数主要要知道两个关键字 async 和 await</p>
<blockquote>
<p>async 用来声明一个异步函数，异步函数的特点就是能在执行过程中挂起等待，等到挂起条件结束后，再继续执行</p>
</blockquote>
<blockquote>
<p>await 用来声明程序此步骤将挂起，比如有两个异步函数async A，和async B，A中某一步有wait，当程序执行到这一步碰到关键字wait时，会将A挂起后，去执行B。当挂起条件小时候，不管B是否执行完毕，会马上从B中跳出，继续执行A.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">url = [<span class="string">&quot;https://www.qq.com/&quot;</span>,</span><br><span class="line">       <span class="string">&quot;https://www.youku.com/&quot;</span>,</span><br><span class="line">       <span class="string">&quot;https://www.baidu.com/&quot;</span>]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = [asyncio.ensure_future(test1(i)) <span class="keyword">for</span> i <span class="keyword">in</span> url]</span><br><span class="line">loop.run_until_complete(asyncio.wait(task))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>asyncio.get_event_loop() 返回当前 OS 线程中正在运行的事件循环。如果没有正在运行的事件循环则会引发 RuntimeError。 此函数只能由协程或回调来调用。</p>
</blockquote>
<blockquote>
<p>asyncio.wait(…) 的参数是一个由future或协程构成的可迭代对象，它会将各个协程包装进一个Task对象里，并且返回的是一个协程或生成器对象。</p>
</blockquote>
<blockquote>
<p>loop.run_until_complete(future)运行直到future( Future 的实例 )被完成。</p>
</blockquote>
<blockquote>
<p>loop.close()关闭事件循环。当这个函数被调用的时候，循环必须处于非运行状态。pending状态的回调将被丢弃。此方法清除所有的队列并立即关闭执行器，不会等待执行器完成。</p>
</blockquote>
<p><font color="red">这里注意，loop.close() 调用时一定要注意，当有其他函数的事件循环仍在运行中时，调用此方法会引发报错</font></p>
<p>更多请看<a href="https://docs.python.org/zh-cn/3.7/library/asyncio.html">官方文档</a></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/20200411162658.png"></p>
<p>回到上文，打包工具中最耗时的是整个流程的第一步：对比本地资源以及服务器资源。我将这一步骤简单地改成了异步函数之后再测试了一番，耗时减少了30s，效果还是非常明显的。接下来这段时间我将继续把一些步骤改造成异步函数，看最终的耗时能降低到多少秒呢？</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Spine动画性能优化</title>
    <url>/2020/03/30/Spine%E5%8A%A8%E7%94%BB%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="Spine"><a href="#Spine" class="headerlink" title="Spine"></a>Spine</h2><p>由于项目需要更好的动画表现效果,于是搜索了一番,发现了spine这款软件,能将2D的动画表现得如同3D一般,效果十分的好,官网上有很多<a href="http://zh.esotericsoftware.com/spine-demos">案例演示</a>可以看看.</p>
<p>下面这是<a href="http://zh.esotericsoftware.com/">官网</a>的部分描述:</p>
<blockquote>
<p>Spine 是一款针对游戏开发的 2D 骨骼动画编辑工具。 Spine 旨在提供更高效和简洁 的工作流程，以创建游戏所需的动画。<br>在 Spine 中通过将图片绑定到骨骼上，然后再控制骨骼实现动画。 2D 骨骼动画相对于传统的逐帧动画有以下优势:</p>
<ul>
<li>最小的体积: 传统的动画需要提供每一帧图片。而 Spine 动画只保存骨骼的动画数据，它所占用的空间非常小，并能为你的游戏提供独一无二的动画。</li>
<li>美术需求: Spine 动画需要的美术资源更少，能为您节省出更多的人力物力更好的投入到游戏开发中去。</li>
<li>流畅性: Spine 动画使用差值算法计算中间帧，这能让你的动画总是保持流畅的效果。</li>
<li>装备附件: 图片绑定在骨骼上来实现动画。如果你需要可以方便的更换角色的装备满足不同的需求。甚至改变角色的样貌来达到动画重用的效果。</li>
<li>混合: 动画之间可以进行混合。比如一个角色可以开枪射击，同时也可以走、跑、跳或者游泳。</li>
<li>程序动画: 可以通过代码控制骨骼，比如可以实现跟随鼠标的射击，注视敌人，或者上坡时的身体前倾等效果。</li>
</ul>
</blockquote>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p>经过一段时间的实验,Spine的动画效果确实不错,但是在性能上仍有些问题.</p>
<ol>
<li><p>场景中加载大量spine动画时会异常卡顿,严重的话甚至会闪退,低端机器尤其明显</p>
</li>
<li><p>动画数据没有缓存机制,同一动画加载多次,内存消耗暴增.</p>
</li>
</ol>
<h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> SkeletonAnimation* <span class="title">createWithJsonFile</span> <span class="params">(<span class="type">const</span> std::string&amp; skeletonJsonFile, <span class="type">const</span> std::string&amp; atlasFile, <span class="type">float</span> scale = <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> SkeletonAnimation* <span class="title">createWithBinaryFile</span> <span class="params">(<span class="type">const</span> std::string&amp; skeletonBinaryFile, <span class="type">const</span> std::string&amp; atlasFile, <span class="type">float</span> scale = <span class="number">1</span>)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过导出的.json文件或者.skel文件创建一个SkeletonAnimation,即一个spine动画实例</p>
<p>由于同一个动画,导出的.json文件,要比二进制.skel文件大上不少,我强烈建议spine动画都采用二进制导出,<br>在解析效率、以及文件大小上都更有优势</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function">SkeletonAnimation* <span class="title">SkeletonAnimation::createWithBinaryFile</span> <span class="params">(<span class="type">const</span> std::string&amp; skeletonBinaryFile, <span class="type">const</span> std::string&amp; atlasFile, <span class="type">float</span> scale)</span> </span>&#123;</span><br><span class="line">	SkeletonAnimation* node = <span class="keyword">new</span> <span class="built_in">SkeletonAnimation</span>();</span><br><span class="line">	spAtlas* atlas = <span class="built_in">spAtlas_createFromFile</span>(atlasFile.<span class="built_in">c_str</span>(), <span class="number">0</span>);</span><br><span class="line">	node-&gt;<span class="built_in">initWithBinaryFile</span>(skeletonBinaryFile, atlas, scale);</span><br><span class="line">	node-&gt;<span class="built_in">autorelease</span>();</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SkeletonRenderer::initWithBinaryFile</span> <span class="params">(<span class="type">const</span> std::string&amp; skeletonDataFile, spAtlas* atlas, <span class="type">float</span> scale)</span> </span>&#123;</span><br><span class="line">		_atlas = atlas;</span><br><span class="line">		_attachmentLoader = <span class="built_in">SUPER</span>(<span class="built_in">Cocos2dAttachmentLoader_create</span>(_atlas));<span class="comment">//创建AttachmentLoader</span></span><br><span class="line"></span><br><span class="line">		spSkeletonBinary* binary = <span class="built_in">spSkeletonBinary_createWithLoader</span>(_attachmentLoader);<span class="comment">//解析binary文件</span></span><br><span class="line">		binary-&gt;scale = scale;</span><br><span class="line">		spSkeletonData* skeletonData = <span class="built_in">spSkeletonBinary_readSkeletonDataFile</span>(binary, skeletonDataFile.<span class="built_in">c_str</span>());<span class="comment">//将解析后的binary转换为skeletonData</span></span><br><span class="line">		<span class="built_in">CCASSERT</span>(skeletonData, binary-&gt;error ? binary-&gt;error : <span class="string">&quot;Error reading skeleton data file.&quot;</span>);</span><br><span class="line">		<span class="built_in">spSkeletonBinary_dispose</span>(binary);<span class="comment">//释放binary解析的占用</span></span><br><span class="line">		_ownsSkeleton = <span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">setSkeletonData</span>(skeletonData, <span class="literal">true</span>);<span class="comment">//将skeletonData赋予当前的SkeletonRenderer</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">initialize</span>();<span class="comment">//初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>分析二进制文件创建spine动画的源码可以看出,加载spine动画时,需要读取解析json文件里的动画信息,并转换为内存对象.</p>
<p>而这整个过程是阻塞的,当大量动画同时加载时,造成阻塞的时间较长,就会出现问题1的情况</p>
<p>针对这个问题，可以避免同一个时间加载过多的Spine动画，采取分帧加载，这样可以分摊压力，不至于瞬间卡死。但是这种方法无法解决第二个问题</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>一开始的时候,我是打算新建SpineCache类来保存skeletonData,当加载重复的spine动画时,直接把上次缓存的skeletonData返回即可，这样既避免了内存暴涨，又避免了多余的加载过程。</p>
<p>但是在过程中发现一些问题:</p>
<ul>
<li>skeletonData的缓存占用,对于大部分手机设备来说可以接受,但是在智能手表设备上,运行越久,会导致应用不流畅.</li>
<li>针对skeletonData的缓存做出某些修改的话,这些修改也会在后续创建的重复的spine生效,这是我并不希望看到的.</li>
</ul>
<p>于是我打算只保存解析json文件之后获得的spSkeletonJson,当加载重复的spine动画时,直接把上次解析获得的spSkeletonJson返回,只省略重复的解析消耗.</p>
<p>虽然加载动画的速度并没有直接缓存skeletonData来得快,但也比原来的加载速度快很多,同时缓存的占用也变得可以接受</p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cocos/editor-support/spine/spine-cocos2dx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cocos2d.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">USING_NS_CC;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> spine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimSpineCache</span> : <span class="keyword">public</span> cocos2d::Ref</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AnimSpineCache</span>();</span><br><span class="line">	~<span class="built_in">AnimSpineCache</span>();</span><br><span class="line">	<span class="function"><span class="type">static</span> AnimSpineCache* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">spine::SkeletonAnimation* <span class="title">createAnimation</span><span class="params">(<span class="type">const</span> std::string&amp; binaryFile, <span class="type">const</span> std::string&amp; atlasFile, <span class="type">float</span> scale = <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">spSkeletonBinary* <span class="title">getSkeletonBinary</span><span class="params">(<span class="type">const</span> std::string&amp; atlasFile)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> AnimSpineCache* sAnimSpineCache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> std::map&lt;std::string, spSkeletonBinary*&gt; m_animDataTable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AnimSpineCache.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;spine/SkeletonAnimation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;spine/extension.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">AnimSpineCache* AnimSpineCache::sAnimSpineCache = <span class="literal">nullptr</span>;</span><br><span class="line">std::map&lt;std::string, spSkeletonBinary*&gt; AnimSpineCache::m_animDataTable;</span><br><span class="line"></span><br><span class="line">AnimSpineCache::<span class="built_in">AnimSpineCache</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AnimSpineCache::~<span class="built_in">AnimSpineCache</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">clearCache</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AnimSpineCache* <span class="title">AnimSpineCache::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> == sAnimSpineCache)</span><br><span class="line">	&#123;</span><br><span class="line">		sAnimSpineCache = <span class="keyword">new</span> <span class="built_in">AnimSpineCache</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sAnimSpineCache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建spine动画,如果缓存，则不重新加载。</span></span><br><span class="line"><span class="function">spine::SkeletonAnimation* <span class="title">AnimSpineCache::createAnimation</span><span class="params">(<span class="type">const</span> std::string&amp; binaryFile, <span class="type">const</span> std::string&amp; atlasFile, <span class="type">float</span> scale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">CCLOG</span>(<span class="string">&quot;createAnimation binaryFile is %s&quot;</span>, binaryFile.<span class="built_in">c_str</span>());</span><br><span class="line">	spine::SkeletonAnimation* node = <span class="keyword">new</span> <span class="built_in">SkeletonAnimation</span>();</span><br><span class="line">	spSkeletonBinary* skeletonBinary = <span class="built_in">getSkeletonBinary</span>(atlasFile);</span><br><span class="line">	spSkeletonData* skeletonData;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> == skeletonBinary)</span><br><span class="line">	&#123;</span><br><span class="line">		spAtlas* atlas = <span class="built_in">spAtlas_createFromFile</span>(atlasFile.<span class="built_in">c_str</span>(), <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">CCASSERT</span>(atlas, <span class="string">&quot;Error reading atlas file.&quot;</span>);</span><br><span class="line"></span><br><span class="line">		spAttachmentLoader* attachmentLoader = <span class="built_in">SUPER</span>(<span class="built_in">Cocos2dAttachmentLoader_create</span>(atlas));</span><br><span class="line"></span><br><span class="line">		skeletonBinary = <span class="built_in">spSkeletonBinary_createWithLoader</span>(attachmentLoader);</span><br><span class="line">		skeletonBinary-&gt;scale = scale;</span><br><span class="line">		skeletonData = <span class="built_in">spSkeletonBinary_readSkeletonDataFile</span>(skeletonBinary, binaryFile.<span class="built_in">c_str</span>());</span><br><span class="line">		<span class="built_in">CCASSERT</span>(skeletonData, skeletonBinary-&gt;error ? skeletonBinary-&gt;error : <span class="string">&quot;Error reading skeleton data file.&quot;</span>);</span><br><span class="line">		m_animDataTable.<span class="built_in">insert</span>(std::map&lt;std::string, spSkeletonBinary*&gt;::<span class="built_in">value_type</span>(atlasFile, skeletonBinary));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		skeletonBinary-&gt;scale = scale;</span><br><span class="line">		skeletonData = <span class="built_in">spSkeletonBinary_readSkeletonDataFile</span>(skeletonBinary, binaryFile.<span class="built_in">c_str</span>());</span><br><span class="line">		<span class="built_in">CCASSERT</span>(skeletonData, skeletonBinary-&gt;error ? skeletonBinary-&gt;error : <span class="string">&quot;Error reading skeleton data file.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	spine::SkeletonAnimation* node = <span class="keyword">new</span> <span class="built_in">SkeletonAnimation</span>();</span><br><span class="line">	node-&gt;<span class="built_in">initWithData</span>(skeletonData, <span class="literal">false</span>);</span><br><span class="line">	node-&gt;<span class="built_in">autorelease</span>();</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">spSkeletonBinary* <span class="title">AnimSpineCache::getSkeletonBinary</span><span class="params">(<span class="type">const</span> std::string&amp; atlasFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::map&lt;std::string, spSkeletonBinary*&gt;::iterator it = m_animDataTable.<span class="built_in">find</span>(atlasFile);</span><br><span class="line">	<span class="keyword">if</span> (it != m_animDataTable.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> it-&gt;second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出游戏，或者关卡结束释放。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimSpineCache::clearCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::map&lt;std::string, spSkeletonBinary*&gt;::iterator it = m_animDataTable.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it != m_animDataTable.<span class="built_in">end</span>(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		spSkeletonBinary* p = it-&gt;second;</span><br><span class="line">		<span class="built_in">spSkeletonBinary_dispose</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	m_animDataTable.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试spine动画性能的过程中,发现了一些内存泄漏的现象,接下来的文章再具体分析分析……</p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Spine</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/01/hello-world/</url>
    <content><![CDATA[<p>欢迎来到<a href="https://hexo.io/">Hexo</a>！这是您的第一篇文章。查看<a href="https://hexo.io/docs/">文档</a>以获取更多信息。如果在使用Hexo时遇到任何问题，可以在<a href="https://hexo.io/docs/troubleshooting.html">故障排除</a>中找到答案，或者可以在<a href="(https://github.com/hexojs/hexo/issues)">GitHub</a>上问我。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>JMeter安装步骤</title>
    <url>/2020/06/02/jmeter%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h2 id="JMeter介绍"><a href="#JMeter介绍" class="headerlink" title="JMeter介绍"></a>JMeter介绍</h2><blockquote>
<p>Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能&#x2F;回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。</p>
</blockquote>
<blockquote>
<p>更多详情请前往<a href="https://jmeter.apache.org/">官网</a>查看</p>
</blockquote>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h3><p>(jdk安装包，双击进行安装)</p>
<p>在<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">java开发套件</a>中找到对应的jdk版本，下载并安装。我下载的是 jdk-8u191-windows-x64.exe 版本</p>
<h3 id="解压安装包后进行配置环境变量"><a href="#解压安装包后进行配置环境变量" class="headerlink" title="解压安装包后进行配置环境变量"></a>解压安装包后进行配置环境变量</h3><ol>
<li>系统变量-&gt;新建 JAVA_HOME 变量，变量值填写jdk的安装目录（本人是F:\jdk），如下图</li>
</ol>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/Snipaste_2020-06-02_14-08-52.png"></p>
<ol start="2">
<li>系统变量-&gt;新建 CLASSPATH 变量，变量值填写 .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar; (注意最前面有一点)</li>
</ol>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/Snipaste_2020-06-02_14-15-00.png"></p>
<ol start="3">
<li>系统变量-&gt;寻找到 Path 变量-&gt; 编辑 ， 在变量值最后添加 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</li>
</ol>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/Snipaste_2020-06-02_14-11-48.png"></p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/Snipaste_2020-06-02_14-12-29.png"></p>
<ol start="4">
<li>检验是否配置成功 ， 运行cmd 输入 java -version ， 如果出现如下结果，则说明JDK环境变量配置成功</li>
</ol>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/Snipaste_2020-06-02_14-20-26.png"></p>
<h3 id="下载并解压-JMeter"><a href="#下载并解压-JMeter" class="headerlink" title="下载并解压 JMeter"></a>下载并解压 JMeter</h3><p>在<a href="https://jmeter.apache.org/download_jmeter.cgi">JMeter</a>中找到对应的版本并解压。我安装的是 apache-jmeter-3.2.rar 版本</p>
<h3 id="运行-JMeter"><a href="#运行-JMeter" class="headerlink" title="运行 JMeter"></a>运行 JMeter</h3><p>进入解压路径并找到 jmeter.exe</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/Snipaste_2020-06-02_14-33-14.png"></p>
<p>打开后界面如下 </p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/image007.png"></p>
<p>添加一个线程组</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/image009.png"></p>
<p>添加：结果树和聚合报告</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/image011.png"></p>
<p>点击线程组进行填写数据.（设置用户量的时候，别设置太大，不然直接把服务器搞崩）</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/image013.png"></p>
<p>填写HTTP请求内容</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/image015.png"></p>
<p>运行</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/image017.png"></p>
<p>这个其实是看 聚合报告的 错误率。（在http请求里，慢慢的增加用户量，来测试该接口能承受的压力）</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/image019.png"></p>
<p>聚合报告可看的性能测试内容（其余可用adb命令或者Android Studio来查看）</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/image021.png"></p>
]]></content>
      <categories>
        <category>测试学习</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
        <tag>接口测试</tag>
      </tags>
  </entry>
  <entry>
    <title>unity练习(一)生命游戏</title>
    <url>/2020/03/27/unity%E7%BB%83%E4%B9%A0-%E4%B8%80-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>啥也不说先贴个github地址：<a href="https://github.com/LofterAltair/LifeGame">生命游戏</a></p>
<p>独立游戏一直是我心里的一个想法，虽然艰难，但是总觉得吧不去试试还是有些遗憾的。</p>
<p>工作中较常使用到的是cocos引擎。不过大学期间制作的第一个游戏便是使用的unity，所以一直对unity十分有好感（也可能是cocos坑太多了）</p>
<p>这周就用unity实现一个比较常见且出名的游戏：生命游戏</p>
<p>顺便熟悉一下unity。</p>
<p>生命游戏，就我个人理解比起游戏更偏向于是一个演化模型。以下是百度百科的内容:</p>
<blockquote>
<p>细胞自动机（又称元胞自动机），名字虽然很深奥，但是它的行为却是非常美妙的。所有这些怎样实现的呢？<br>我们可以把计算机中的宇宙想象成是一堆方格子构成的封闭空间，尺寸为N的空间就有N<em>N个格子。<br>而每一个格子都可以看成是一个生命体，每个生命都有生和死两种状态，如果该格子生就显示蓝色，死则显示白色。<br>每一个格子旁边都有邻居格子存在，如果我们把3</em>3的9个格子构成的正方形看成一个基本单位的话，那么这个正方形中心的格子的邻居就是它旁边的8个格子。<br>每个格子的生死遵循下面的原则：</p>
<ol>
<li>如果一个细胞周围有3个细胞为生（一个细胞周围共有8个细胞），则该细胞为生（即该细胞若原先为死，则转为生，若原先为生，则保持不变） 。</li>
<li>如果一个细胞周围有2个细胞为生，则该细胞的生死状态保持不变；</li>
<li>在其它情况下，该细胞为死（即该细胞若原先为生，则转为死，若原先为死，则保持不变）设定图像中每个像素的初始状态后依据上述的游戏规则演绎生命的变化，由于初始状态和迭代次数不同，将会得到令人叹服的优美图案。</li>
</ol>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LifeGame</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    &amp;lt;</span><br><span class="line">    pre&amp;gt;</span><br><span class="line">    &amp;lt;</span><br><span class="line">    code&amp;gt; <span class="comment">// Use this for initialization</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Image image;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MapSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> [,</span><br><span class="line">    ] LifeMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> [,</span><br><span class="line">    ] preLifeMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList ImageMap=<span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector2 [] RoundCell=<span class="keyword">new</span> Vector2[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> distance=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> distancetime=<span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> nexttime=<span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> refreshCount=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isDone=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义cell四周的向量</span></span><br><span class="line"></span><br><span class="line">        RoundCell[<span class="number">0</span>]=<span class="keyword">new</span> Vector2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        RoundCell[<span class="number">1</span>]=<span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        RoundCell[<span class="number">2</span>]=<span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        RoundCell[<span class="number">3</span>]=<span class="keyword">new</span> Vector2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        RoundCell[<span class="number">4</span>]=<span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        RoundCell[<span class="number">5</span>]=<span class="keyword">new</span> Vector2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        RoundCell[<span class="number">6</span>]=<span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        RoundCell[<span class="number">7</span>]=<span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        LifeMap=<span class="keyword">new</span> <span class="built_in">int</span>[MapSize,</span><br><span class="line">        MapSize];</span><br><span class="line"></span><br><span class="line">        preLifeMap=<span class="keyword">new</span> <span class="built_in">int</span>[MapSize,</span><br><span class="line">        MapSize];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化每个格子的生命</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> row=LifeMap.GetLength(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> col=LifeMap.GetLength(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j &#123;</span><br><span class="line"></span><br><span class="line">                        LifeMap[i, j]=Random.Range(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//Debug.Log(i+&quot;行&quot;+j+&quot;列得到的随机数：&quot;+LifeMap[i,j]);</span></span><br><span class="line"></span><br><span class="line">                        createImage(i, j);</span><br><span class="line"></span><br><span class="line">                        setImageColor(i, j, LifeMap[i, j]);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update is called once per frame</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nexttime &amp;lt; distancetime) &#123;</span><br><span class="line"></span><br><span class="line">                    nexttime +=Time.deltaTime;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    nexttime=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(isDone) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    updateLifeMap();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ( !compareList(preLifeMap, LifeMap)) &#123;</span><br><span class="line"></span><br><span class="line">                        refreshCount++;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        isDone=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                        Debug.Log(MapSize+<span class="string">&quot;*&quot;</span>+MapSize+<span class="string">&quot;生命游戏的寿命为：&quot;</span>+refreshCount+<span class="string">&quot;代&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="built_in">bool</span> <span class="title">compareList</span>(<span class="params"><span class="built_in">int</span> [, ] preLifeMap, <span class="built_in">int</span> [, ] curLifeMap</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> row=LifeMap.GetLength(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">int</span> col=LifeMap.GetLength(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span>(preLifeMap[i, j] !=curLifeMap[i, j]) &#123;</span><br><span class="line"></span><br><span class="line">                                    preLifeMap[i, j]=curLifeMap[i, j];</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="keyword">void</span> <span class="title">updateLifeMap</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">int</span> row=LifeMap.GetLength(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">int</span> col=LifeMap.GetLength(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>; j &#123;</span><br><span class="line"></span><br><span class="line">                                        <span class="built_in">int</span> liveCellNum=CheckRoundCell(i, j);</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">//1． 如果一个细胞周围有3个细胞为生（一个细胞周围共有8个细胞），则该细胞为生（即该细胞若原先为死，则转为生，若原先为生，则保持不变） 。</span></span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">if</span>(liveCellNum==<span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">                                            LifeMap[i, j]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                                            setImageColor(i, j, LifeMap[i, j]);</span><br><span class="line"></span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">else</span> <span class="keyword">if</span> (liveCellNum &amp;lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">                                            LifeMap[i, j]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                                            setImageColor(i, j, LifeMap[i, j]);</span><br><span class="line"></span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">else</span> <span class="keyword">if</span> (liveCellNum==<span class="number">2</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">else</span> <span class="keyword">if</span> (liveCellNum &amp;gt; <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">                                            LifeMap[i, j]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                                            setImageColor(i, j, LifeMap[i, j]);</span><br><span class="line"></span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="function"><span class="built_in">int</span> <span class="title">CheckRoundCell</span>(<span class="params"><span class="built_in">int</span> cellcow, <span class="built_in">int</span> cellRol</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="built_in">int</span> liveCellNum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="built_in">int</span> row=LifeMap.GetLength(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                                <span class="built_in">int</span> col=LifeMap.GetLength(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                                Vector2 cell=<span class="keyword">new</span> Vector2(cellcow, cellRol);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&amp;lt; RoundCell.Length; i++) &#123;</span><br><span class="line"></span><br><span class="line">                                    Vector2 checkVector=RoundCell[i];</span><br><span class="line"></span><br><span class="line">                                    Vector2 lifeCell=<span class="keyword">new</span> Vector2(cellcow, cellRol)+checkVector;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (lifeCell.x&amp;gt; =<span class="number">0</span> &amp;amp; &amp;amp; lifeCell.y&amp;gt; =<span class="number">0</span> &amp;amp; &amp;amp; lifeCell.x &#123;</span><br><span class="line"></span><br><span class="line">                                            <span class="keyword">if</span>(LifeMap[(<span class="built_in">int</span>)lifeCell.x, (<span class="built_in">int</span>)lifeCell.y] &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                                                liveCellNum++;</span><br><span class="line"></span><br><span class="line">                                            &#125;</span><br><span class="line"></span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">return</span> liveCellNum;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="function"><span class="keyword">void</span> <span class="title">createImage</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> j</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="built_in">int</span> row=LifeMap.GetLength(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                                    <span class="built_in">int</span> col=LifeMap.GetLength(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                                    <span class="built_in">int</span> size=Screen.height &amp;lt; Screen.width ? Screen.height : Screen.width;</span><br><span class="line"></span><br><span class="line">                                    <span class="built_in">int</span> num=row &amp;lt; col ? row : col;</span><br><span class="line"></span><br><span class="line">                                    <span class="built_in">float</span> scale=size/num;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>(ImageMap.Count &amp;lt; row*col) &#123;</span><br><span class="line"></span><br><span class="line">                                        Image tempImage=(Image) Instantiate (image);</span><br><span class="line"></span><br><span class="line">                                        tempImage.GetComponent().SetParent(GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).GetComponent(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                                        tempImage.GetComponent().sizeDelta=<span class="keyword">new</span> Vector2(scale, scale);</span><br><span class="line"></span><br><span class="line">                                        tempImage.GetComponent().localPosition=<span class="keyword">new</span> Vector3((i<span class="number">-1</span>-row/<span class="number">2</span>)*(scale+distance), (j<span class="number">-1</span>-col/<span class="number">2</span>)*(scale+distance), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                                        ImageMap.Insert(ImageMap.Count, tempImage);</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="function"><span class="keyword">void</span> <span class="title">setImageColor</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> j, <span class="built_in">int</span> color</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="built_in">int</span> row=LifeMap.GetLength(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                                    Image tempImage=(Image)ImageMap[i*row+j];</span><br><span class="line"></span><br><span class="line">                                    Color newColor=color==<span class="number">1</span> ? Color.red:Color.white;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (tempImage !=<span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                                        tempImage.color=newColor;</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是15*15 的生命游戏演化结果，运行至2168代</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/1571666-60cb36a4316f36ca.png"></p>
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>碰撞检测方案(四叉树)</title>
    <url>/2020/03/27/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88-%E5%9B%9B%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>最近要做一个类似于球球大作战的项目，游戏运行中会不断进行大量的碰撞检测，需要适合的碰撞检测方案，所以在网上搜索了一下资料。下面是找到的几种方案。</p>
<h2 id="碰撞检测方案"><a href="#碰撞检测方案" class="headerlink" title="碰撞检测方案"></a>碰撞检测方案</h2><h3 id="方案一：循环遍历"><a href="#方案一：循环遍历" class="headerlink" title="方案一：循环遍历"></a>方案一：循环遍历</h3><ul>
<li>在游戏场景运行期间，会每帧调用update()，在update函数中循环遍历场景中所有的物体，通过计算物体中心点的距离来判断物体是否碰撞</li>
<li>试想如果场景中有N个物体，对每两个物体都进行碰撞检测，那时间复杂度就有N^2，效率低。而且实际上一个位于场景左下角的物体与一个位于场景右上角的物体明显不可能发生碰撞</li>
</ul>
<h3 id="方案一：循环遍历-1"><a href="#方案一：循环遍历-1" class="headerlink" title="方案一：循环遍历"></a>方案一：循环遍历</h3><ul>
<li>可以在scene添加物理世界，将所有的物体都设置成物理刚体，通过chipmunk的碰撞回调实现碰撞检测</li>
<li>之前做游戏遇到过刚体速度太快出现碰撞穿透现象，所以此次不采用此方案</li>
</ul>
<h3 id="方案三：四叉树优化碰撞检测"><a href="#方案三：四叉树优化碰撞检测" class="headerlink" title="方案三：四叉树优化碰撞检测"></a>方案三：四叉树优化碰撞检测</h3><ul>
<li>使用四叉树空间索引，减少需要遍历的物体数量，大大减少了计算量</li>
<li>说得太多主要还是因为我没有使用过四叉树~ 想尝试一下~</li>
</ul>
<h2 id="四叉树原理"><a href="#四叉树原理" class="headerlink" title="四叉树原理"></a>四叉树原理</h2><p>网上可以查到许多关于四叉树的资料。四叉树是一个每个父节点都具有四个子节点的树状数据结构。我们将屏幕划分为四个区域，用于区分处于不同位置的物体，四叉树的四个节点正合适表示这四个区域。<br>方便起见将四块区域命名为象限一、二、三、四。</p>
<p><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/1571666-dcf2190163565eb0.png"><br>我们将完全处于某一个象限的物体存储在该象限对应的子节点下，当然，也存在跨越多个象限的物体，我们将它们存在父节点中，如下图所示：<br><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/1571666-a99df86a6716d0f4.png"><br>如果某个象限内的物体的数量过多，它会同样会分裂成四个子象限，以此类推：<br><img src="https://lofaltair-1253512131.cos.ap-guangzhou.myqcloud.com/1571666-f3824bd27b1792b3.png"></p>
<h2 id="lua实现四叉树"><a href="#lua实现四叉树" class="headerlink" title="lua实现四叉树"></a>lua实现四叉树</h2><figure class="highlight lua"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> QuadTree = &#123;&#125;</span><br><span class="line">QuadTree.<span class="built_in">__index</span> = QuadTree</span><br><span class="line"></span><br><span class="line">QuadTree.MAX_OBJECTS = <span class="number">10</span></span><br><span class="line">QuadTree.MAX_LEVELS = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">checkbounds</span><span class="params">(quadrant, box)</span></span></span><br><span class="line">    <span class="keyword">local</span> list = &#123;</span><br><span class="line">        cc.p(box.x + box.width, box.y + box.height),</span><br><span class="line">        cc.p(box.x + box.width, box.y + box.height),</span><br><span class="line">        cc.p(box.x + box.width, box.y + box.height),</span><br><span class="line">        cc.p(box.x + box.width, box.y + box.height),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, pos <span class="keyword">in</span> <span class="built_in">pairs</span>(list) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (pos.x &gt;= quadrant.x <span class="keyword">and</span> pos.x &lt;= quadrant.x + quadrant.width <span class="keyword">and</span> pos.y &gt;= quadrant.y <span class="keyword">and</span> pos.y &lt;= quadrant.y + quadrant.height) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--bounds 屏幕范围</span></span><br><span class="line"><span class="comment">--level 四叉树层级</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuadTree:new</span><span class="params">(bounds, level)</span></span></span><br><span class="line">    <span class="keyword">local</span> o = &#123;&#125;</span><br><span class="line">    o = <span class="built_in">setmetatable</span>(o,QuadTree)</span><br><span class="line">    o.objects = &#123;&#125;</span><br><span class="line">    o.nodes = &#123;&#125;</span><br><span class="line">    o.level = level <span class="keyword">and</span> level <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">    o.bounds = bounds</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--   获取物体对应的象限序号，以屏幕中心为界限，切割屏幕:</span></span><br><span class="line"><span class="comment">--   - 右上：象限一</span></span><br><span class="line"><span class="comment">--   - 左上：象限二</span></span><br><span class="line"><span class="comment">--   - 左下：象限三</span></span><br><span class="line"><span class="comment">--   - 右下：象限四</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuadTree:getIndex</span><span class="params">(node)</span></span></span><br><span class="line">    <span class="keyword">local</span> rect = node:getBoundingBox()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> checkbounds(<span class="built_in">self</span>.bounds, rect) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> x = <span class="built_in">self</span>.bounds.x</span><br><span class="line">    <span class="keyword">local</span> y = <span class="built_in">self</span>.bounds.y</span><br><span class="line">    <span class="keyword">local</span> width = <span class="built_in">self</span>.bounds.width / <span class="number">2</span></span><br><span class="line">    <span class="keyword">local</span> height = <span class="built_in">self</span>.bounds.height / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> quadrant1 = cc.rect(x + width, y + height, width, height)</span><br><span class="line">    <span class="keyword">local</span> quadrant2 = cc.rect(x, y + height, width, height)</span><br><span class="line">    <span class="keyword">local</span> quadrant3 = cc.rect(x, y, width, height)</span><br><span class="line">    <span class="keyword">local</span> quadrant4 = cc.rect(x + width, y, width, height)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> checkbounds(quadrant1, rect) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elseif</span> checkbounds(quadrant2, rect) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">elseif</span> checkbounds(quadrant3, rect) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">elseif</span> checkbounds(quadrant4, rect) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--如果物体跨越多个象限，则放回-1</span></span><br><span class="line">    <span class="keyword">return</span> - <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuadTree:split</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> #<span class="built_in">self</span>.nodes &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> x = <span class="built_in">self</span>.bounds.x</span><br><span class="line">    <span class="keyword">local</span> y = <span class="built_in">self</span>.bounds.y</span><br><span class="line">    <span class="keyword">local</span> width = <span class="built_in">self</span>.bounds.width / <span class="number">2</span></span><br><span class="line">    <span class="keyword">local</span> height = <span class="built_in">self</span>.bounds.height / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> tree1 = QuadTree:new(cc.rect(x + width, y + height, width, height), <span class="built_in">self</span>.level + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">local</span> tree2 = QuadTree:new(cc.rect(x, y + height, width, height), <span class="built_in">self</span>.level + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">local</span> tree3 = QuadTree:new(cc.rect(x, y, width, height), <span class="built_in">self</span>.level + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">local</span> tree4 = QuadTree:new(cc.rect(x + width, y, width, height), <span class="built_in">self</span>.level + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">self</span>.nodes, tree1)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">self</span>.nodes, tree2)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">self</span>.nodes, tree3)</span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">self</span>.nodes, tree4)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入功能：</span></span><br><span class="line"><span class="comment">--     - 如果当前节点[ 存在 ]子节点，则检查物体到底属于哪个子节点，如果能匹配到子节点，则将该物体插入到该子节点中</span></span><br><span class="line"><span class="comment">--     - 如果当前节点[ 不存在 ]子节点，将该物体存储在当前节点。随后，检查当前节点的存储数量，如果超过了最大存储数量，则对当前节点进行划分，划分完成后，将当前节点存储的物体重新分配到四个子节点中。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuadTree:insert</span><span class="params">(node)</span></span></span><br><span class="line">    <span class="comment">--如果该节点下存在子节点</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>,tolua.<span class="built_in">type</span>(node))</span><br><span class="line">    <span class="keyword">if</span> #<span class="built_in">self</span>.nodes &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> index = <span class="built_in">self</span>:getIndex(node)</span><br><span class="line">        <span class="keyword">if</span> index <span class="keyword">and</span> index ~= - <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">self</span>.nodes[index]:<span class="built_in">insert</span>(node)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--否则存储在当前节点下</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(<span class="built_in">self</span>.objects, node)</span><br><span class="line"></span><br><span class="line">    <span class="comment">--如果当前节点存储的数量超过了MAX_OBJECTS</span></span><br><span class="line">    <span class="keyword">if</span> #<span class="built_in">self</span>.nodes &lt;= <span class="number">0</span> <span class="keyword">and</span> #<span class="built_in">self</span>.objects &gt; QuadTree.MAX_OBJECTS</span><br><span class="line">    <span class="keyword">and</span> <span class="built_in">self</span>.level &lt; QuadTree.MAX_LEVELS <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">self</span>:split()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i = #<span class="built_in">self</span>.objects, <span class="number">1</span>, - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> index = <span class="built_in">self</span>:getIndex(<span class="built_in">self</span>.objects[i])</span><br><span class="line">            <span class="keyword">if</span> index <span class="keyword">and</span> index ~= - <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">self</span>.nodes[index]:<span class="built_in">insert</span>(<span class="built_in">self</span>.objects[i])</span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">remove</span>(<span class="built_in">self</span>.objects, i)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检索功能：</span></span><br><span class="line"><span class="comment">--  给出一个物体对象，该函数负责将该物体可能发生碰撞的所有物体选取出来。该函数先查找物体所属的象限，该象限下的物体都是有可能发生碰撞的，然后再递归地查找子象限...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuadTree:retrieve</span><span class="params">(node)</span></span></span><br><span class="line">    <span class="keyword">local</span> result = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> #<span class="built_in">self</span>.nodes &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> index = <span class="built_in">self</span>:getIndex(node)</span><br><span class="line">        <span class="keyword">if</span> index <span class="keyword">and</span> index ~= - <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> list = <span class="built_in">self</span>.nodes[index]:retrieve(node)</span><br><span class="line">            <span class="keyword">for</span> _,value <span class="keyword">in</span> <span class="built_in">pairs</span>(list) <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(result, value)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> index <span class="keyword">and</span> index == - <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> x = <span class="built_in">self</span>.bounds.x</span><br><span class="line">            <span class="keyword">local</span> y = <span class="built_in">self</span>.bounds.y</span><br><span class="line">            <span class="keyword">local</span> width = <span class="built_in">self</span>.bounds.width / <span class="number">2</span></span><br><span class="line">            <span class="keyword">local</span> height = <span class="built_in">self</span>.bounds.height / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">local</span> quadrant1 = cc.rect(x + width, y + height, width, height)</span><br><span class="line">            <span class="keyword">local</span> quadrant2 = cc.rect(x, y + height, width, height)</span><br><span class="line">            <span class="keyword">local</span> quadrant3 = cc.rect(x, y, width, height)</span><br><span class="line">            <span class="keyword">local</span> quadrant4 = cc.rect(x + width, y, width, height)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">local</span> rect = node:getBoundingBox()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> checkbounds(quadrant1, rect) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> list = <span class="built_in">self</span>.nodes[<span class="number">1</span>]:retrieve(node)</span><br><span class="line">                <span class="keyword">for</span> _,value <span class="keyword">in</span> <span class="built_in">pairs</span>(list) <span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">table</span>.<span class="built_in">insert</span>(result, value)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> checkbounds(quadrant2, rect) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> list = <span class="built_in">self</span>.nodes[<span class="number">2</span>]:retrieve(node)</span><br><span class="line">                <span class="keyword">for</span> _,value <span class="keyword">in</span> <span class="built_in">pairs</span>(list) <span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">table</span>.<span class="built_in">insert</span>(result, value)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> checkbounds(quadrant3, rect) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> list = <span class="built_in">self</span>.nodes[<span class="number">3</span>]:retrieve(node)</span><br><span class="line">                <span class="keyword">for</span> _,value <span class="keyword">in</span> <span class="built_in">pairs</span>(list) <span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">table</span>.<span class="built_in">insert</span>(result, value)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> checkbounds(quadrant4, rect) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">local</span> list = <span class="built_in">self</span>.nodes[<span class="number">4</span>]:retrieve(node)</span><br><span class="line">                <span class="keyword">for</span> _,value <span class="keyword">in</span> <span class="built_in">pairs</span>(list) <span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">table</span>.<span class="built_in">insert</span>(result, value)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,value <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">self</span>.objects) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(result, value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--判断矩形是否在象限范围内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuadTree:isInner</span><span class="params">(node, bounds)</span></span></span><br><span class="line">    <span class="keyword">local</span> rect = node:getBoundingBox()</span><br><span class="line">    <span class="keyword">return</span> rect.x &gt;= bounds.x <span class="keyword">and</span> rect.x + rect.width &lt;= bounds.x + bounds.width</span><br><span class="line">    <span class="keyword">and</span> rect.y &gt;= bounds.y <span class="keyword">and</span> rect.y + rect.height &lt;= bounds.y + bounds.height</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 动态更新：</span></span><br><span class="line"><span class="comment">-- 从根节点深入四叉树，检查四叉树各个节点存储的物体是否依旧属于该节点（象限）的范围之内，如果不属于，则重新插入该物体。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuadTree:refresh</span><span class="params">(root)</span></span></span><br><span class="line">    root = root <span class="keyword">or</span> <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">for</span> i = #<span class="built_in">self</span>.objects, <span class="number">1</span>, - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> node = <span class="built_in">self</span>.objects[i]</span><br><span class="line">        <span class="keyword">local</span> index = <span class="built_in">self</span>:getIndex(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index <span class="keyword">then</span></span><br><span class="line">            <span class="comment">--如果矩形不属于该象限，则将该矩形重新插入</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">self</span>:isInner(node, <span class="built_in">self</span>.bounds) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">self</span> ~= root <span class="keyword">then</span></span><br><span class="line">                    root:<span class="built_in">insert</span>(<span class="built_in">self</span>.objects[i])</span><br><span class="line">                    <span class="built_in">table</span>.<span class="built_in">remove</span>(<span class="built_in">self</span>.objects, i)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">--  如果矩形属于该象限 且 该象限具有子象限，则</span></span><br><span class="line">                <span class="comment">--  将该矩形安插到子象限中</span></span><br><span class="line">            <span class="keyword">elseif</span> #<span class="built_in">self</span>.nodes &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">self</span>.nodes[index]:<span class="built_in">insert</span>(<span class="built_in">self</span>.objects[i])</span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">remove</span>(<span class="built_in">self</span>.objects, i)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #<span class="built_in">self</span>.nodes <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">self</span>.nodes[i]:refresh(root)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> QuadTree</span><br></pre></td></tr></table></figure>

<p>后期实际运用到项目里面的时候，发现还缺少了移除节点，以及清除整个四叉树的接口<br>四叉树中object的结构我存的是CCNODE</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--移除四叉树节点中的object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuadTree:remove</span><span class="params">(removeNode)</span></span></span><br><span class="line">    <span class="keyword">for</span> i = #<span class="built_in">self</span>.objects, <span class="number">1</span>, - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> node = <span class="built_in">self</span>.objects[i]</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">and</span> node:getTag() == removeNode:getTag() <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">remove</span>(<span class="built_in">self</span>.objects, i)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #<span class="built_in">self</span>.nodes <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">self</span>.nodes[i]:<span class="built_in">remove</span>(removeNode) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--清理四叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuadTree:clear</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i = #<span class="built_in">self</span>.objects, <span class="number">1</span>, - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">remove</span>(<span class="built_in">self</span>.objects,i)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">self</span>.objects = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #<span class="built_in">self</span>.nodes <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">self</span>.nodes[i]:clear()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>碰撞检测</tag>
        <tag>四叉树</tag>
      </tags>
  </entry>
</search>
